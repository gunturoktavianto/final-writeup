While reverse engineering the Shopee `x-sap-sec` generation code, I've been able to determine where the final payload is assembled (from a `Uint8Array`). This is most likely shortly after the encryption algorithm is complete and provides a solid base for further reverse engineering.

I will list my findings and approach, below.

# Summary

## Key Findings, Next Steps

We're looking for the value of the `x-sap-sec` header, which is an ASCII payload. I've been able to trace that back to a binary payload that appears to be a raw byte array (`Uint8Array`). Both of these appear random, which is consistent with the provided information indicating that they're encrypted.

Next steps would be to determine how this byte array is built up, which would hopefully reveal information about the encryption algorithm and the underlying data that goes into the payload.

## Program Structure, etc.

The original code makes heavy use of extremely large functions, significant iteration/recursion, dynamically generated code (fed through `eval`), and other anti-analysis techniques.

Some - perhaps all? - of the dynamic code uses variable names starting with the U+FC5E character followed by one or two ASCII digits, which is rather obnoxious to print (it ends up looking like an encoding error). Any time that the dynamic code needs to be displayed, I suggest reformatting it so that the identifiers do _not_ use a raw U+FC5E.

# Analysis and Walkthrough

I decided to use a "start at the end, work backwards" approach, as I believed (correctly, IMO) that this would allow for efficient progress without having to understand the whole of the obfuscated code.

I have also added various numbered annotations to the `.27.224_deobfuscated.js` file; the modified version is attached. When looking for a numbered annotation of mine (e.g., "note 1"), the quickest way to find it will be to search for `#1` in the code.

## Finding an entry point

Having been told that the `x-sap-sec` header is printed to the browser console inside of `index.html`, the first step was to determine where that data comes from, as shown in the unmodified snippet below:

```js
let sec_code = await module.default.generateSignEntry(url, body_str);
console.log(sec_code);
```

This tells me that the `generateSignEntry` function spits out `x-sap-sec`. Opening up the `.js` file, I see that `generateSignEntry` appears directly in the code (**note 1**), allowing me to continue following the chain backwards to the origin. Unfortunately, `x-sap-sec` is generated by the following line of code:

```js
jt.apply(this, [o, {}, i, 933, this, r, 996]);
```

This `jt` function comes up repeatedly, and I will refer to it colloquially as an "unholy mess"; it is _not_ viable to dissect it directly. So, we need to use a different approach that does not require understanding the entirety of `jt()`.

## Probing inside of `jt()`, first time through

In order to actually make progress, I chose to use a Proxy to probe what is going on inside of the `jt()` function (see **note 3**). I noticed that `i[0].pop()` is the place where the `x-sap-sec` header is returned from `generateSignEntry`, so I chose `i[0]` as the target for the Proxy. Specifically, I set up a handler for the inverse of `push`, on a hunch that the obfuscated code pushes something and then pops it.

This yielded immediate results (see **note 4**), and brought me to the following (original) code:

```js
((Dt = He(r[h++])),
o[o.length - 1][ht](Dt),
<...omitted...>)
```

(note: the third line is irrelevant, aside from containing the closing parenthesis)

I could tell that _something_ was going on here, and since I was already injecting a Proxy, I chose to investigate by modifying the code to add relevant logging. I determined that `He(r[h++]))` is the most interesting part of that section, because `He(r[h++])` is where the `x-sap-sec` object is retrieved from.

If I recall correctly, the specific flow here is that the payload is retrieved from the deep recesses of the obfuscation inside of `He()`, at which point the payload is assigned into `Dt`, and then the second line here ends up equating to `o[0]['push'](payload)` -- where the `o[0]` on this line is the same as the `i[0]` from earlier (remember, note 3).

## Dynamically generated function `He()`

Unfortunately, on the relevant iteration through the code, `He` is a dynamically generated function (created using `eval` from a string), which prevents direct modification or probing. The data of interest was also stored inside a variable that the function had closed over, _also_ dynamically generated (and with a very annoying identifier, of the form `(\u{fc5e}11)` where `11` was a random number on each run of `generateSignEntry`).

This dynamic function was significant enough that I dubbed it "**note5**" for ease of reference, and it can be found by searching for `function note5` in the modified JS. Similarly, the variable that I was trying to probe, is one that I've renamed to "**note6**".

After reformatting, renaming/adding identifiers, and introducing a `ret` variable to hold the return value (for easier inspecting), the `note5` function has the following structure:

```js
(function note5(arg0, arg1) {
  let ret = ((arg1 = arg0 & 15), note6[arg1][arg0 >> 4]);
  return ret;
});
```

Essentially, it's doing `return note6[i][j]`, for some `note6`, `i`, and `j`. The first index (`i`) was never of interest, but `note6` (a data storage object) and `j` (specifically, indices `j = 129` and `j = 162`) are both interesting, as discussed in the "Summary" section above.

## Inspecting the dynamically generated `note5()` function

Once I determined that I needed access to a variable that exists only in dynamically-generated code, I switched my approach from Proxy-based probing back to the browser debugger. By stepping into the dynamic function, I was able to examine the callstack, which brought me to where it invoked (**note 7**), as well as a line right above that where it was defined (**note 8**):

```js
(st = ct(Ft()))), /* NOTE #8 */
(He = He || st(o)), /* NOTE #7 */
```

The note #7 line is mostly useful because it provided an anchoring point in the execution flow; the real prize here is being able locate note #8, where the `note5` function is _defined_.

Specifically, `ct = eval`, so we can rewrite that line as follows:

```js
(st = eval(Ft()))),
```

Very luckily, `Ft()` was always returning a structurally-identical piece of code (consisting of two nested anonymous functions, with `note5()` being the inner one and the `note6` variable defined in the outer function), although the numbers on the identifiers did vary from run to run.

This allowed me to replace that whole `eval(...)` with a static piece of code, and then _heavily_ probe it by modifying it further (see the **note 8** section of the modified code).

## Inspecting the now-static `note5()` function

At this point, with a static `(function note5() { ... })`, I was able to probe the overall logic a lot more.

I observed that `note5()` is called many, MANY times; over 40k. However, the payload object is returned from `note5()` on only 5 runs: run #2649 (0-indexed), and #40471 - #40474.

Switching back to `Proxy` and custom logging as my tools of choice, I observed that on run 2649, the payload did not yet exist (the _object_ did, but it was empty); but on run 40471, the payload existed in `note6[0][129]`. Furthermore, I was able to determine that the object _did_ need to be an object; replacing it with `null` produces an interesting error message (see `structure.md`; the error isn't important to the analysis, so I'm omitting it here).

We'll call the object of interest (stored in `note5[0][129]`) "**note 9**, for reference.

So, using a similar approach to the start, I intercepted the `set` operation on the note 9 object (i.e., I intercepted code similar to `note6[0][129]['x-sap-sec'] =`). Switching to the debugger, I located the `x-sap-sec` variable, and then followed the call stack until the outermost place in the stack where it appears, which I'm calling the **note 11** line:

```js
res = de[lt](pe, ee),
```

On this line, `res` stores the string value of `x-sap-sec`.

## Investigating note 11 and locating a Uint8Array

Similarly to the rest of the code, this line gets executed _many_ times, so I added debug code to help me isolate it. Specifically, I wanted to look for an invocation where `res = (...)` was a value that was consistent with `x-sap-sec`, and I chose: a string, with length >= 200, and no spaces.

This way, I determined that when `res =` is assigned the payload value, `ee` is a Uint8Array that is roughly 75% the size of the ASCII payload. This STRONGLY suggests that the ASCII payload is an ASCII-encoded form of this same byte array. Therefore, I assume that the Uint8Array in question (which I'll refer to as "**note 12**") is the binary payload.

Tracking the note12 payload a bit farther back, I determined that it _also_ passes through the same `note5()` function and `note6[0]` variable; in this case, it lives in `note6[0][162]`. Unfortunately, that's about as far as my time allowed me to trace things.

## Next steps

Having found where the ASCII-encoded payload is assembled from the binary payload, the next step would be to probe the binary payload object and determine how the binary payload itself is built up.

# Reverse Engineering Tools and Approach

## Proxy class, for object inspection

Of particular note is the JS `Proxy` class. This allows a piece of code (under our control) to modify an object, in such a way that we can intercept operations performed on that object in an entirely different piece of code (not under our control). This proved EXTREMELY useful as a way to skip over large sections of irrelevant code execution, and focus only on the areas where interesting stuff was happening.

## Custom utility functions

The file `debug-utils.js` contains various utility functions, which were useful for inserting debug code into the obfuscated source.
